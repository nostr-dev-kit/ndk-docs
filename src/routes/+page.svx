<script lang="ts">
    import SectionHeader from '$lib/components/SectionHeader.svelte'
    import TableOfContents from '$lib/components/TableOfContents.svelte'

    let tableOfContents: App.NavLink[] = [
        { title: 'Installation', url: '#Installation' },
        { title: 'Debugging', url: '#Debugging' },
        { title: 'Support', url: '#Support', sublinks: [{title: "NDK NIP-28 Group Chat", url: "#NDK-NIP-28-Group-Chat"}] },
        { title: 'Instantiate an NDK instance', url: '#Instantiate-an-NDK-Instance' },
        { title: 'Connecting', url: '#Connecting' },
        { title: 'Signers', url: '#Signers', sublinks: [
            {title: "NIP-07 Browser Extensions", url: "#NIP-07-Browser-Extensions"},
            {title: "NIP-46 Remote Signing", url: "#NIP-46-Remote-Signing"}
        ] },
        { title: 'Caching', url: '#Caching', sublinks: [{title: "Using a Cache Adapter", url: "#Using-a-Cache-Adapter"}] },
        { title: 'Buffered Queries', url: '#Buffered-Queries' },
        { title: 'Intelligent Relay Selection', url: '#Intelligent-Relay-Selection' },
        { title: 'Subscription Management', url: '#Subscription-Management' },
        { title: 'Architecture Decisions', url: '#Architecture-Decisions' },
    ];
</script>

<div class="contentWrapper">
<h1 class="gradientText">Nostr Development Kit</h1>

NDK is a Nostr development kit that makes the experience of building Nostr-related applications, whether they are relays, clients, or anything in between, better, more reliable and overall nicer to work with than existing solutions.

Besides improving the developer experience, the core goal of NDK is to improve the decentralization of Nostr via intelligent conventions and data discovery features without depending on any one central point of coordination (such as large relays or centralized search providers).

<SectionHeader title="Installation" />

```sh
npm add @nostr-dev-kit/ndk
```

If you're in a real hurry, jump straight to our page on [common patterns & uses of NDK](/guides/common-patterns).

<SectionHeader title="Debugging" />

NDK uses the `debug` package to assist in understanding what's happening behind the hood. If you are building a package
that runs on the server define the `DEBUG` envionment variable.

```
export DEBUG='ndk:*'
```

Or, in the browser, enable it by running the following command the developer console.

```
localStorage.debug = 'ndk:*'
```

<SectionHeader title="Support" />

<SectionHeader title="NDK NIP-28 Group Chat" subheader={true} />

* [Coracle](https://app.coracle.social/chat/note15m6rdfvlmd0z836hk83sg7r59xtv23qnmamhsslq5uc6744fdm4qfkeat3)
* [Nostrchat](https://www.nostrchat.io/channel/a6f436a59fdb5e23c757b1e30478742996c54413df777843e0a731af56a96eea)

<SectionHeader title="Instantiate an NDK Instance" />

You can pass an object with several options to a newly created instance of NDK.

-   `explicitRelayUrls` - an array of relay URLs.
-   `signer` - an instance of a [signer](#signers).
-   `cacheAdapter` - an instance of a [Cache Adapter](#caching)
-   `debug` - boolean true/false to turn on degbugging

```ts
// Import the package
import NDK from "@nostr-dev-kit/ndk";
// Create a new NDK instance with explicit relays
ndk = new NDK({ explicitRelayUrls: ["wss://a.relay", "wss://another.relay"] });
```

Note: In normal client use, it's best practice to instantiate NDK as a singleton class. [See more below](#Architecture-Decisions).

<SectionHeader title="Connecting" />

After you've instatiated NDK, you need to tell it to connect before you'll be able to interact with any relays.

```ts
// Import the package
import NDK from "@nostr-dev-kit/ndk";
// Create a new NDK instance with explicit relays
ndk = new NDK({ explicitRelayUrls: ["wss://a.relay", "wss://another.relay"] });

// Now connect to specified relays
await ndk.connect();
```

<SectionHeader title="Signers" />

NDK uses signers _optionally_ passed in to sign events. Note that it is possible to use NDK without signing events (e.g. [to get someone's profile](https://github.com/nostr-dev-kit/ndk-cli/blob/master/src/commands/profile.ts)).

Signing adapters can be passed in when NDK is instantiated or later during runtime.

<SectionHeader title="NIP-07 Browser Extensions" subheader={true} />

Instatiate NDK with a NIP-07 signer (e.g. Alby, nos2x)

```ts
// Import the package, NIP-07 signer and NDK event
import NDK, { NDKNip07Signer, NDKEvent } from "@nostr-dev-kit/ndk";

const nip07signer = new NDKNip07Signer();
const ndk = new NDK({ signer: nip07signer });
```

NDK can now ask for permission, via their NIP-07 extension, to...

**Read the user's public key**

```ts
nip07signer.user().then(async (user) => {
    if (!!user.npub) {
        console.log("Permission granted to read their public key:", user.npub);
    }
});
```

**Sign & publish events**

```ts
const ndkEvent = new NDKEvent(ndk);
ndkEvent.kind = 1;
ndkEvent.content = "Hello, world!";
ndkEvent.publish(); // This will trigger the extension to ask the user to confirm signing.
```

<SectionHeader title="NIP-46 Remote Signing" subheader={true} />

```ts
const signingAdapter = new NDK.RemoteSignerAdapter();
const ndk = new NDK({ signingAdapter });
const event = ndk.event();
event.kind = 0;
event.content = "This event is signed via NIP-46.";
await event.publish();
```

<SectionHeader title="Caching" />

NDK provides database-agnostic caching functionality out-of-the-box to improve the performance of your application and reduce load on relays.

NDK will eventually allow you to use multiple caches simultaneously and allow for selective storage of data in the cache store that makes the most sense for your application.

The most important data to cache is _where_ a user or note might be found. UX suffers profoundly when this type of data cannot be found. By design, the Nostr protocol leaves beadcrums of where a user or note might be found and NDK does it's best to store this data automatically and use it when you query for events.

<SectionHeader title="Using a Cache Adapter" subheader={true} />

```ts
const redisAdapter = new RedisAdapter(redisUrl);
const ndk = new NDK({ cacheAdapter: redisAdapter });
```

<SectionHeader title="Buffered Queries" />

Clients often need to load data (e.g. profile data) from individual components at once (e.g. initial page render). This typically causes multiple subscriptions to be submitted fetching the same information and causing poor performance or getting rate-limited/maxed out by relays.

NDK implements a convenient subscription model, _buffered queries_, where a named subscription will be created after a customizable amount of time, so that multiple components can append queries.

```ts
// Component 1
ndk.bufferedSubscription({ kinds: [0], authors: ["pubkey-1"] }, "profiles", 500);

// Component 2
ndk.bufferedSubscription({ kinds: [0], authors: ["pubkey-2"] }, "profiles", 500);
```

In this example, NDK will wait 500ms before creating a subscription with the filter:

```ts
{kinds: [0], authors: ['pubkey-1', 'pubkey-2'] }
```

<SectionHeader title="Intelligent Relay Selection" />

When a client submits a request through NDK, NDK will calculate which relays are most likely able to satisfy this request.

Queries submitted by the client might be broken into different queries if NDK computes different relays.

For example, say npub-A follows npub-B and npub-C. If the NDK client uses:

```ts
const ndk = new NDK({ explicitRelays: ["wss://nos.lol"] });
const npubA = ndk.getUser("npub-A");
const feedEvents = await npubA.feed();
```

This would result in the following request:

```json
{ "kinds": [1], "authors": ["npub-B", "npub-C"] }
```

But if NDK has observed that `npub-B` tends to write to `wss://userb.xyz` and
`npub-C` tends to write to `wss://userc.io`, NDK will instead send the following queries.

```json
// to npub-A's explicit relay wss://nos.lol *if* npub-B and npub-C have been seen on that relay
{ "kinds": [1], "authors": [ "npub-B", "npub-C" ] }

// to wss://userb.xyz
{ "kinds": [1], "authors": [ "npub-B" ] }

// to wss://userc.io
{ "kinds": [1], "authors": [ "npub-C" ] }
```

<SectionHeader title="Subscription Management" />

Often, clients need to fetch data but don't need to maintain an open connection to the relay. This is true of profile metadata requests especially.

-   The `autoclose` flag will make the connection close immediately after EOSE is seen.
-   An integer `autoclose` will close the connection after that amount of ms after EOSE is seen.

```ts
ndk.subscription({ kinds: [0], authors: ["..."] }, { autoclose: true });
```

<SectionHeader title="Architecture Decisions" />

-   Users of NDK should instantiate a single NDK instance.
-   That instance tracks state with all relays connected, explicit and otherwise.
-   All relays are tracked in a single pool that handles connection errors/reconnection logic.
-   RelaySets are assembled ad-hoc as needed depending on the queries set, although some RelaySets might be long-lasting, like the `explicitRelays` specified by the user.
-   RelaySets are always a subset of the pool of all available relays.

</div>

<TableOfContents links={tableOfContents} />
